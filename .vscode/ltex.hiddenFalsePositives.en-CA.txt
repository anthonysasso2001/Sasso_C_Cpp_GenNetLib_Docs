{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QSeparate documentations for SassoCCppGenNetLib intended to be included as a submodule or similar to help segregate the code better.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QSassoCCppGenNetLib Documentation By: Anthony Sasso\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsecnumdepth 0\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QSassoCCppGenNetLib By: Anthony Sasso\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QOptionally this header may also exist as a linker for other, sub headers in the form of “StructNameDataBuffer.h/.hpp” and then pointed to using “DataBufferStructures” as a reference of sorts.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QA seperate header including the struct contained within “DataBuffer” should be expected to exist on each side of the network in the form of a file named “DataBufferStructures.h/.hpp” which will define the DataBuffer overloads for each struct.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QA separate .h/.hpp file including the struct contained within “DataBuffer” should be expected to exist on each side of the network in the form of a file named “DataBufferStructures.h/.hpp” which will define the DataBuffer overloads for each struct.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QA separate .h/.hpp file including the struct contained within “DataBuffer” should be expected to exist on each side of the network in the form of a file named “DataBufferStructures.h/.hpp” which will define the DataBuffer overloads for each struct.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QOptionally this file may also exist as a linker for other, sub headers in the form of “StructNameDataBuffer.h/.hpp” and then pointed to using “DataBufferStructures” as a reference of sorts.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QFor the four types of requirements they will have naming schemes as follows: NAMEZZYYYY(-XX) where Z denotes the major requirement category, Y the individual requirement ID, and X an optional sub-requirement specification (such as having a USER010001, USER010001-A, & USER010001-B).\\E$"}
{"rule":"TOO_LONG_PARAGRAPH","sentence":"^\\QThis object will use a 'bitset<flagBArrSize>' object cast to unsigned long during serializations, giving a max number of 32 flags.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_CA","sentence":"^\\QThis object will use a 'bitset<flagBArrSize>' object cast to unsigned long during serializations, giving a max number of 32 flags.\\E$"}
